Android Studio NDK开发-环境配置
一、NDK
1.NDK全称Native Development Kit
2.NDK提供了一系列的工具，可以帮助开发者在Android平台上面进行c/c++的开发，并能自动将.so打包金apk中
3.NDK集成了交叉编译器，并提供mk文件可以做到隔离CPU,平台以及ABI等差异，只需修改mk文件即可。开发人员只需要简单修改mk文件，就可以创建出适应各平台的.so文件
4.NDK开发就是使用c/c++开发Android应用或者开发Android应用的某一个功能，使用NDK有时是为了调用底层的库,有时是为了c/c++开发带来的应用性能上的提高

二、使用流程
1.在main文件夹中创建cpp文件夹，cpp中创建CMakeLists.txt

2.编写CMakeLists.txt最常用的功能就是调用其他的.h头文件和.so/.a库文件，将.cpp/.c/.cc文件编译成可执行文件或者新的库文件

3.创建一个native-lib.cpp文件
里面方法是kotlin要去调用的，编写规则是Java_com_example_kotlinmvpdemo_ndk_nativelib_stringFromJNI
(1)com_example_kotlinmvpdemo_ndk_nativelib 路径
(2)stringFromJNI 方法名

4.在nativelib类中
(1)初始化加载动态库native-lib.so文件
    companion object {
        // Used to load the 'native-lib' library on application startup.
        init {
            System.loadLibrary("native-lib")
        }
    }
(2)Java 中使用 native 声明 ndk 方法 , 在 Kotlin 中 , 使用 external 声明 ndk 方法
external fun stringFromJNI(): String

5.模块build.gradle中配置

android{
...

defaultConfig{
...

        externalNativeBuild {
            cmake {
                cppFlags ""
                //生成一下文件夹中的so文件，生成的文件路径：build/intermediates/cmake/debug/.....
                abiFilters 'arm64-v8a', 'armeabi-v7a', 'x86', 'x86_64'
            }
        }

...

}

    externalNativeBuild {
        cmake {
            path "src/main/cpp/CMakeLists.txt"
            version "3.10.2"
        }
    }

...
}

==================================================== 分割线 ====================================================
Android Studio NDK开发-C语言--基本数据类型
一.C语言的数据类型
1.基本类型
(1).数值类型
a.整型
a1.整型short
a2.整型int
a3.长整型long
b.浮点型
b1.单精度型 float
b2.双精度型 double

(2).字符类型 char

2.构造类型
(1).数组
(2).结构体 struct
(3).公用体 union
(4).枚举类型 enum

3. 指针类型

4.空类型void

二.short、int、long、char、float、double 这六个关键字代表C 语言里的六种基本数据类型
1.格式化输出
(1) int %d
(2) short %d
(3) long %ld
(4) float %f
(5) double %lf
(6) char %c

2.进制输出
(1) %x 十六进制
(2) %o 八进制
(3) %s 字符串
(4) %p一般以十六进制整数方式输出指针的值，附加前缀0x

3.字符占位大小
(1) 在32 位的系统上short 咔出来的内存大小是2 个byte；
(2) int 咔出来的内存大小是4 个byte；
(3) long 咔出来的内存大小是4 个byte；
(4) float 咔出来的内存大小是4 个byte；
(5) double 咔出来的内存大小是8 个byte；
(6) char 咔出来的内存大小是1 个byte。
ps:注意这里指一般情况，可能不同的平台还会有所不同，具体平台可以用sizeof 关键字测试一下

测试方法：testbasictype



==================================================== 分割线 ====================================================
Android Studio NDK开发-C语言--指针
一.前言
1. 通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的
2. 每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址

二.指针的定义
1.指针是一个变量,其值为另一个变量的地址，内存位置的直接地址
2.就像其它变量或常量一样，您必须在使用指针存储其它变量地址之前，对其进行声明。指针变量声明的一般形式为：type *var-name;
3.有效的指针声明
(1).int    *ip;    /* 一个整型的指针 */
(2).double *dp;    /* 一个 double 型的指针 */
(3).float  *fp;    /* 一个浮点型的指针 */
(4).char   *ch;     /* 一个字符型的指针 */

三.如何使用指针
 1. 定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值
 2. 通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值
 3. C 中的 NULL 指针 在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量
 4. 指针有类型，地址没有类型，地址只是开始的位置，类型大小决定读取到什么位置结束
 5. 多级指针，动态内存分配二维数组，操作数组的时候
 6. 指针运算（加减法）（与数组的操作相结合）
 7. 函数指针
 (1).函数指针是指向函数的指针变量,函数指针是指向函数
 (2).函数指针可以像一般函数一样，用于调用函数、传递参数
 (3).typedef int (*fun_ptr)(int,int); // 声明一个指向同样参数、返回值的函数指针类型
 8.回调函数，函数指针作为某个函数的参数


==================================================== 分割线 ====================================================
Android Studio NDK开发-C语言--动态内存分配
一.C 内存管理函数
C 语言为内存的分配和管理提供了几个函数。这些函数可以在 <stdlib.h> 头文件中找到
1.void calloc(int num, int size);
在内存中动态地分配 num 个长度为 size 的连续空间，并将每一个字节都初始化为 0。所以它的结果是分配了 numsize 个字节长度的内存空间，并且每个字节的值都是0。
2.void free(void *address);
该函数释放 address 所指向的内存块,释放的是动态分配的内存空间。
3.void *malloc(int num);
在堆区分配一块指定大小的内存空间，用来存放数据。这块内存空间在函数执行完成后不会被初始化，它们的值是未知的。
4.void *realloc(void *address, int newsize);
该函数重新分配内存，把内存扩展到 newsize。

二.C 语言里面的内存划分
1.栈区（栈内存，存放局部变量，自动分配和释放，里面函数的参数，方法里面的临时变量）
2.堆区（动态内存分配，C语言里面由程序员手动分配），最大值为操作系统的80%
3.全局区或静态区
4.常量区（字符串）
5.程序代码区

三.静态与动态内存分配
1.在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用
2.静态内存分配，分配内存大小的是固定，产生的问题：
(1).很容易超出栈内存的最大值
(2).为了防止内存不够用会开辟更多的内存，容易浪费内存。
3.动态内存分配，在程序运行过程中，动态指定需要使用的内存大小，手动释放，释放之后这些内存还可以被重新使用

四.栈溢出
void main(){
    //属于静态内存分配，分配到栈里面，Window里面每一个应用栈大概是2M，大小确定。与操作系统有关。
    int a [1024 * 1024 * 10 * 4];
}
该静态内存定义为40M，而Window里面每一个应用栈大概是2M，超出了范围， 会报stack overflow错误 。

五.动态内存分配和释放
1.通过动态内存分配来动态指定数组的大小，程序运行过程中，可以随意的开辟指定大小的内存，以供使用，相当于Java中的集合
2.重新分配realloc
(1).缩小内存，缩小的那一部分数据会丢失
(2).扩大内存，（连续的）
A.如果当前内存段后面有需要的内存空间，直接扩展这段内存空间，realloc返回原指针
B.如果当前内存段后面的空闲字节不够，那么就使用堆中的第一个能够满足这一要求的内存块，将目前的数据复制到新的位置，并将原来的数据库释放掉，返回新的内存地址
C.如果申请失败，返回NULL，原来的指针仍然有效

六.内存分配的几个注意细节
(1).不能多次释放
(2).释放完之后（指针仍然有值），给指针置NULL，标志释放完成
(3).内存泄露（p重新赋值之后，再free，并没有真正释放内存）

七.避免内存泄漏：p重新赋值之前先free


==================================================== 分割线 ====================================================
Android Studio NDK开发-C语言--字符串
一. C语言的字符串有两种：
(1).字符数组:数组可以修改其中某一个值，不可以整体赋值。
(2).字符指针:字符指针不可以修改其中某一个值，可以整体赋值。使用指针加法，结合结束符，可以进行截取。

二.字符串常用的方法
(1).strcpy字符串复制
a.把src所指由NULL结束的字符串复制到dest所指的数组中。
b.src和dest所指内存区域不可以重叠且dest必须有足够的空间来容纳src的字符串。返回指向dest的指针
(2).strcat字符串拼接
(2).strchr字符串中查找字符
a.查找字符串s中首次出现字符c的位置
b.返回首次出现c的位置的指针，如果s中不存在c则返回NULL。

==================================================== 分割线 ====================================================
Android NDK开发之旅6 C语言--结构体
一.定义
1.数组允许定义可存储相同类型数据项的变量
2.结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项
struct [structure tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more structure variables];
(1).structure tag 是可选的
(2).每个 member definition 是标准的变量定义
(3).在结构定义的末尾，最后一个分号之前，您可以指定一个或多个结构变量，这是可选的

下面是声明 Book 结构的方式
struct Books
{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;
} book;

二.结构体的使用实例
1.结构体可以在定义之后跟着声明或者初始化变量
struct Man {
	char name[20];
	int age;
}m1, m2 = {"Lucy",35};  //m1结构体变量名

2.匿名结构体 控制结构体变量的个数（限量版），相当于单例
struct {
	char name[20];
	int age;
}m1;

3.结构体嵌套
struct Teacher
{
	char name[20];
};

struct Student
{
	char name[20];
	int age;
	struct Teacher t;
};

4.结构体与指针

5.指针与结构体数组

6.结构体的大小
(1).字节对齐，结构体变量的大小，必须是最宽基本数据类型的整数倍。通过空间换取时间来提升读取效率

7.typedef:取别名，定义新的类型，方便使用
(1).char* pa, pb: 只声明了一个指向字符变量的指针，和一个字符变量
(2).typedef char* PCHAR;
    PCHAR pa, pb;
    这种方式就是定义了两个字符型指针

8.typedef:定义与平台无关的类型
(1).typedef long double REAL;
(2).typedef double REAL;
(1).typedef float REAL;
当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。

9.typedef:为复杂的声明定义一个新的简单的别名
==================================================== 分割线 ====================================================
Android NDK开发之旅7--C语言--联合体与枚举
一.联合体
共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。
您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。
共用体提供了一种使用相同的内存位置的有效方式。

二.定义共用体
1.必须使用 union 语句，方式与定义结构类似

2.union 语句定义了一个新的数据类型，带有多个成员
union [union tag]
{
   member definition;
   member definition;
   ...
   member definition;
} [one or more union variables];
(1).union tag 是可选的,每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义
(2).在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的

3.共用体占用的内存应足够存储共用体中最大的成员。

4.联合变量任何时刻只有一个变量存在，最后一次赋值有效

三.枚举
1.枚举（列举所有的情况），限定值的取值范围，保证取值的安全性
(1).枚举型是一个集合，集合中的元素(枚举成员)是一些命名的整型常量，元素之间用逗号,隔开。
(2).DAY是一个标识符，可以看成这个集合的名字，是一个可选项，即是可有可无的项
(3) 第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。
(4).可以人为设定枚举成员的值，从而自定义某个范围内的整数。
(5).枚举型是预处理指令#define的替代
(6) 类型定义以分号;结束。

==================================================== 分割线 ====================================================
Android NDK开发之旅8--C语言--文件读写
一.文件读写
一个文件，无论它是文本文件还是二进制文件，都是代表了一系列的字节。C 语言不仅提供了访问顶层的函数，也提供了底层（OS）调用来处理存储设备上的文件。

二.打开文件
1.您可以使用 fopen( ) 函数来创建一个新的文件或者打开一个已有的文件，这个调用会初始化类型 FILE 的一个对象，类型 FILE 包含了所有用来控制流的必要的信息
2.下面是这个函数调用的原型
(1).FILE *fopen( const char * filename, const char * mode );
r	打开一个已有的文本文件，允许读取文件。
w	打开一个文本文件，允许写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会从文件的开头写入内容。
a	打开一个文本文件，以追加模式写入文件。如果文件不存在，则会创建一个新文件。在这里，您的程序会在已有的文件内容中追加内容。
r+	打开一个文本文件，允许读写文件。
w+	打开一个文本文件，允许读写文件。如果文件已存在，则文件会被截断为零长度，如果文件不存在，则会创建一个新文件。
a+	打开一个文本文件，允许读写文件。如果文件不存在，则会创建一个新文件。读取会从文件的开头开始，写入则只能是追加模式。
(2).如果处理的是二进制文件，则需使用下面的访问模式来取代上面的访问模式
"rb", "wb", "ab", "rb+", "r+b", "wb+", "w+b", "ab+", "a+b"

三.关闭文件
1.关闭文件，请使用 fclose( ) 函数。函数的原型如下：int fclose( FILE *fp );
2.成功关闭文件，fclose( ) 函数返回零，如果关闭文件时发生错误，函数返回 EOF。这个函数实际上，会清空缓冲区中的数据，关闭文件，并释放用于该文件的所有内存。EOF 是一个定义在头文件 stdio.h 中的常量

四.读取文件
1.从文件读取单个字符的最简单的函数:int fgetc( FILE * fp );
(1).fgetc() 函数从 fp 所指向的输入文件中读取一个字符。返回值是读取的字符，如果发生错误则返回 EOF
2.允许您从流中读取一个字符串：char *fgets( char *buf, int n, FILE *fp );
(1).fgets() 从 fp 所指向的输入流中读取 n - 1 个字符。它会把读取的字符串复制到缓冲区 buf，并在最后追加一个 null 字符来终止字符串
(2)如果这个函数在读取最后一个字符之前就遇到一个换行符 '\n' 或文件的末尾 EOF，则只会返回读取到的字符，包括换行符
(3)也可以使用 int fscanf(FILE *fp, const char *format, ...) 函数来从文件中读取字符串，但是在遇到第一个空格字符时，它会停止读取

五.写入文件
1.把字符写入到流中的最简单的函数：int fputc( int c, FILE *fp );
(1).函数 fputc() 把参数 c 的字符值写入到 fp 所指向的输出流中。如果写入成功，它会返回写入的字符，如果发生错误，则会返回 EOF
(2).使用下面的函数来把一个以 null 结尾的字符串写入到流中：int fputs( const char *s, FILE *fp );
(3).函数 fputs() 把字符串 s 写入到 fp 所指向的输出流中。如果写入成功，它会返回一个非负值，如果发生错误，则会返回 EOF。您也可以使用 int fprintf(FILE *fp,const char *format, ...) 函数来写把一个字符串写入到文件中

六.读写二进制I/O文件
1.计算机的文件存储在物理上都是二进制，文本文件和二进制之分，其实是一个人为的逻辑之分
2.C读写文本文件与二进制文件的差别仅仅体现在回车换行符
(1).写文本时，每遇到一个'\n'，会将其转换成'\r\n'(回车换行)。
(2).读文本时，每遇到一个'\r\n'，会将其转换成'\n'。
(3)但是读写二进制文件的时候并不会做以上转换
3.二进制读写方法

==================================================== 分割线 ====================================================
Android NDK开发之旅9--C语言--预编译
一.C执行的过程
1.编译：形成目标代码
2.链接：将目标代码与C的函数库相链接，合并代码，生成可执行文件
3.运行

二.C预处理器
1.C 预处理器不是编译器的组成部分，但是它是编译过程中一个单独的步骤
2.C 预处理器只不过是一个文本替换工具而已，它们会指示编译器在实际编译之前完成所需的预处理
3.我们将把 C 预处理器（C Preprocessor）简写为 CPP
4.所有的预处理器命令都是以井号（#）开头
#define	    定义宏
#include	包含一个源代码文件
#undef	    取消已定义的宏
#ifdef	    如果宏已经定义，则返回真
#ifndef	    如果宏没有定义，则返回真
#if	        如果给定条件为真，则编译下面代码
#else #if	的替代方案
#elif	    如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
#endif	    结束一个 #if……#else 条件编译块
#error	    当遇到标准错误时，输出错误消息
#pragma	    使用标准化方法，向编译器发布特殊的命令到编译器中

三.宏定义、宏替换
1.定义标识
(1).例如通过判断一些标识是否定义来判断是否支持某种语法、平台等等
A.表示支持C++语法
#ifdef __cplusplus
#endif

B.表示支持Android、Windows、苹果平台等等
#ifdef ANDROID
#endif

(2).防止头文件重复引入

2.定义常数(便于修改和阅读)
#define MAX 100
void main(){
    int i = 100;
    if (i == MAX){
        printf("哈哈");
    }
    getchar();
}

3.定义“宏函数”
(1).实质上就是一个替换的过程
#define GET_MIN(A,B) A < B ? A : B
 int main(){
     int a = 100;
     int b = 200;
     int c = GET_MIN(100, 200);
     printf("最小值: %d\n", c);
     getchar();
     return 0;
 }
结果输出：
最小值: 100

4.Android中LOG简化示例
(1).#define LOG(FORMAT,...) printf(FORMAT,__VA_ARGS__);   ... 三个点表示可变参数与__VA_ARGS__ 对应
(2).在Android JNI开发的时候，我们打印一句日志是通过__android_log_print函数来实现的
__android_log_print(ANDROID_LOG_INFO, "FFmpeg", "%s", "fix");

四.预定义宏
1.ANSI C 定义了许多宏。在编程中您可以使用这些宏，但是不能直接修改这些预定义的宏
__ DATE__	当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
__ TIME__	当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
__ FILE__	这会包含当前文件名，一个字符串常量。
__ LINE__	这会包含当前行号，一个十进制常量。
__ STDC__	当编译器以 ANSI 标准编译时，则定义为 1。

五.预处理器运算符
1.C 预处理器提供了下列的运算符来帮助您创建宏
(1).宏延续运算符（\）
一个宏通常写在一个单行上。但是如果宏太长，一个单行容纳不下，则使用宏延续运算符（\）

(2).字符串常量化运算符#
在宏定义中，当需要把一个宏的参数转换为字符串常量时，则使用字符串常量化运算符#。在宏中使用的该运算符有一个特定的参数或参数列表

(3).标记粘贴运算符##
宏定义内的标记粘贴运算符##会合并两个参数。它允许在宏定义中两个独立的标记被合并为一个标记

(4).defined() 运算符
预处理器 defined 运算符是用在常量表达式中的，用来确定一个标识符是否已经使用 #define定义过。如果指定的标识符已定义，则值为真（非零）。如果指定的标识符未定义，则值为假（零）

(5).参数化的宏
A.CPP 一个强大的功能是可以使用参数化的宏来模拟函数\
B.使用带有参数的宏之前，必须使用 #define 指令定义。参数列表是括在圆括号内，且必须紧跟在宏名称的后边。宏名称和左圆括号之间不允许有空格

==================================================== 分割线 ====================================================
Android NDK开发之旅10--JNI--JNI开发流程
一.NDK
1.NDK: Native Development Kit，NDK提供了一系列的工具，帮助开发者快速开发C（或C++）的动态库，并能自动将so和java应用一起打包成apk

2. 使用NDK的原因:
(1).安全。Java容易反编译，C/C++不容易
(2).效率。Java实现效率低或者不能实现。

二.JNI
1.JNI（Java Native Interface）：Java调用C/C++，C/C++调用Java的一套API。

2.NDK开发需要用到JNI

三.JNI开发流程
1.编写native方法。

2.javah命令，生成.h头文件。

3.复制.h头文件到CPP工程中。

4.复制jni.h和jni_md.h文件到CPP工程中。

5.实现.h头文件中声明的函数。

6.生成dll文件。

7.配置dll文件所在目录到环境变量。

8.重启Eclipse。

四.动态库与静态库
1.如果使用静态库，全部都会包含在最终生成的exe文件。动态库是不会包含的，运行的时候才会被程序加载进来。
2.动态库可以多个应用共享（加载即可），加载不加载可以随时由程序完成。

五.JNI开发中JNIEnv在C和C++中实现的区别
1.JNIEnv：JNIEnv里面有很多方法，与Java进行交互，代表Java的运行环境。JNI Environment

2.在C中JNIEnv 结构体指针的别名 env 二级指针

3.在C++中JNIEnv 是一个结构体的别名 env 一级指针

==================================================== 分割线 ====================================================
Android NDK开发之旅11--JNI--JNI数据类型与方法属性访问
一.JNI数据类型
1.JNI的数据类型包含两种: 基本类型和引用类型

2.基本类型
(1).基本类型主要有jboolean, jchar, jint等, 它们和Java中的数据类型对应关系如下表所示
Java类型	JNI类型	    描述
boolean	    jboolean	无符号8位整型
byte	    byte	    无符号8位整型
char	    jchar	    无符号16位整型
short	    jshort	    有符号16位整型
int	        jint	    32位整型
long	    jlong	    64位整型
float	    jfloat	    32位浮点型
double	    jdouble	    64位浮点型
void	    void	    无类型

3.引用类型(对象)
(1).JNI中的引用类型主要有类, 对象和数组. 它们和Java中的引用类型的对应关系如下表所示:
Java类型	JNI类型	        描述
Object	    jobject	      Object类型
Class	    jclass	      Class类型
String	    jstring	      String类型
Object[]	jobjectArray   对象数组
boolean[]	jbooleanArray  boolean数组
byte[]	    jbyteArray	   byte数组
char[]	    jcharArray	   char数组
short[]	    jshortArray	   short数组
int[]	    jintArray	   int数组
long[]	    jlongArray	   long数组
float[]	    jfloatArray	   float数组
double[]	jdoubleArray   double数组
Throwable	jthrowable	   Throwable


二.关于属性与方法的签名
数据类型	签名
boolean	     Z
byte	     B
char	     C
short	     S
int	         I
long	     J
float	     F
double	     D
ully-qualified-class	Lfully-qualified-class;
type[]	     [type
method type	 (arg-types)ret-type

1.类描述符开头的 'L' 与结尾的 ';' 必须要有

2.数组描述符,开头的 '[' 必须要有

3.方法描述符规则: "(各参数描述符)返回值描述符",其中参数描述符间没有任何分隔符号




二.native函数参数说明
1.每个native函数，都至少有两个参数（JNIEnv*,jclass或者jobject)

2.当native方法为静态方法时：
  jclass 代表native方法所属类的class对象(JniTest.class)

3.当native方法为非静态方法时：
  jobject 代表native方法所属的对象

三.C/C++访问Java的属性、方法
1.访问Java的非静态属性

2.访问Java的静态属性

3.访问Java的非静态方法

4.访问Java类的构造方法

5.间接访问Java类的父类的方法

 四.总结
 1. C/C++完成的功能并不是所有代码一定要C/C++语句写，有时候C/C++可以调用现成的Java方法或属性解决问题，能起到事半功倍的作用

 2.属性、方法的访问的使用是和Java的反射相类似




==================================================== 分割线 ====================================================







