Android的设计模式-设计模式的六大原则:
一、单一职责原则：一个类应只包含单一的职责
1.一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的
2.其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则

二、开放封闭原则：一个模块、类、函数应当是对修改关闭，扩展开放
1.修改原有的代码可能会导致原本正常的功能出现问题
2.因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码

三、里氏代换原则：使用父类的地方能够使用子类来替换，反过来，则不行
1.使用子类对象去替换父类对象，程序将不会产生错误
2.因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象

四、依赖倒转原则：抽象不应该依赖于细节，细节应当依赖于抽象
1.即要面向接口编程，而不是面向具体实现去编程
2.高层模块不应该依赖低层模块，应该去依赖抽象

五、接口隔离法则：一个类对另一个类的依赖应该建立在最小的接口上
1.一个类不应该依赖他不需要的接口
2.接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口

六、迪米特法则：一个类尽量不要与其他类发生关系
1.一个类对其他类知道的越少，耦合越小
2.当修改一个类时，其他类的影响就越小，发生错误的可能性就越小

==================================================== 分割线 ====================================================
创建型模式---单例模式
一、定义：确保某个类只有一个实例,并且自行实例化并向整个系统提供这个实例

二、特点
 1. 单例类只能有一个实例。
 2. 单例类必须自己创建自己的唯一实例。
 3. 单例类必须给所有其他对象提供这一实例。

三、类型
1.饿汉式
优点：写法简单，线程安全。
缺点：没有懒加载的效果，如果没有使用过的话会造成内存浪费。
2.懒汉式（线程不安全）
优点：实现了懒加载的效果。
缺点：线程不安全。
3.懒汉式（线程安全）
优点：实现了懒加载的效果，线程安全。
缺点：使用synchronized会造成不必要的同步开销，而且大部分时候我们是用不到同步的。
4.双重检查锁定(DCL)
优点：懒加载，线程安全，效率较高
缺点：volatile影响一点性能，高并发下有一定的缺陷，某些情况下DCL会失效，虽然概率较小。
5.静态内部类
优点：懒加载，线程安全，推荐使用
6.枚举单例
优点：线程安全，写法简单，能防止反序列化重新创建新的对象。
缺点：可读性不高，枚举会比静态常量多那么一丁点的内存。

四、应用场景
频繁访问数据库或文件的对象。
工具类对象；
创建对象时耗时过多或耗费资源过多，但又经常用到的对象；

五、优点
内存中只存在一个对象，节省了系统资源。
避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。

六、缺点
获取对象时不能用new
单例对象如果持有Context，那么很容易引发内存泄露。
单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。
==================================================== 分割线 ====================================================
创建型模式---建造者模式
一、定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

二、特点：
1.建造者模式主要用来创建复杂的对象，用户可以不用关心其建造过程和细节。
2.例如：当要组装一台电脑时，我们选择好CPU、内存、硬盘等等，然后交给装机师傅，装机师傅就把电脑给组装起来，我们不需要关心是怎么拼装起来的。

三、角色说明：
Product（产品类）：要创建的复杂对象。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。
Builder（抽象建造者）：创建产品的抽象接口，一般至少有一个创建产品的抽象方法和一个返回产品的抽象方法。引入抽象类，是为了更容易扩展。
ConcreteBuilder（实际的建造者）：继承Builder类，实现抽象类的所有抽象方法。实现具体的建造过程和细节。
Director（指挥者类）：分配不同的建造者来创建产品，统一组装流程。

四、应用场景
创建一些复杂的对象时,对象内部的构建过程存在复杂变化。
相同的构建过程，不同的执行顺序，产生不同结果时。
不同配置的构建对象，产生不同结果时。

五、优点
封装性良好，隐藏内部构建细节。
易于解耦，将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。
易于扩展，具体的建造者类之间相互独立，增加新的具体建造者无需修改原有类库的代码。
易于精确控制对象的创建，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

六、缺点
产生多余的Builder对象以及Director类。
建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。


举例分析：Android中的AlertDialog.Builder就是使用了Builder模式来构建AlertDialog的
==================================================== 分割线 ====================================================
创建型模式---工厂方法模式
一、定义：定义一个用于创建对象的接口，让子类决定实例化哪个类

二、特点
工厂方法模式主要用来创建复杂的对象，简单对象能够使用new来创建就不用工厂方法模式来创建了

三、角色说明：
  Product（抽象产品类）：要创建的复杂对象，定义对象的公共接口。
  ConcreteProduct（具体产品类）：实现Product接口。
  Factory（抽象工厂类）：该方法返回一个Product类型的对象。
  ConcreteFactory（具体工厂类）：返回ConcreteProduct实例。

四、应用场景
生成复杂对象时，无需知道具体类名，只需知道相应的工厂方法即可

五、优点
1.符合开放封闭原则。新增产品时，只需增加相应的具体产品类和相应的工厂子类即可。
2.符合单一职责原则。每个具体工厂类只负责创建对应的产品。

六、缺点
1.一个具体工厂只能创建一种具体产品。
2.增加新产品时，还需增加相应的工厂类，系统类的个数将成对增加，增加了系统的复杂度和性能开销。
3.引入的抽象类也会导致类结构的复杂化。

举例分析：Android中的ThreadFactory就是使用了工厂方法模式来生成线程的，线程就是ThreadFactory的产品
==================================================== 分割线 ====================================================
创建型模式---简单工厂模式
一、定义：定义一个用于创建对象的接口，让子类决定实例化哪个类

二、特点
简单工厂模式又叫做静态工厂方法模式

三、角色说明
Product（抽象产品类）：要创建的复杂对象，定义对象的公共接口。
ConcreteProduct（具体产品类）：实现Product接口。
Factory（工厂类）：返回ConcreteProduct实例。

四、应用场景
生成复杂对象时，确定只有一个工厂类，可以使用简单工厂模式。否则有多个工厂类的话，使用工厂方法模式

五、优点
代码解耦，创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建。

六.缺点
1.违背开放封闭原则，若需添加新产品则必须修改工厂类逻辑，会造成工厂逻辑过于复杂。
2.简单工厂模式使用了静态工厂方法，因此静态方法不能被继承和重写。
3.工厂类包含了所有实例（产品）的创建逻辑，若工厂类出错，则会造成整个系统都会会受到影响。

==================================================== 分割线 ====================================================
创建型模式---抽象工厂模式
一、定义：为创建一组相关或者相互依赖的对象提供一个接口，而无需指定它们的具体类

二、特点
1.工厂方法模式每个工厂只能创建一种类型的产品，而抽象工厂模式则能够创建多种类型的产品。

三、角色说明：
AbstractProduct（抽象产品类）：定义产品的公共接口。
ConcreteProduct（具体产品类）：定义产品的具体对象，实现抽象产品类中的接口。
AbstractFactory（抽象工厂类）：定义工厂中用来创建不同产品的方法。
ConcreteFactory（具体工厂类）：实现抽象工厂中定义的创建产品的方。

四、应用场景
生产多个产品组合的对象时。

五、优点
代码解耦，创建实例的工作与使用实例的工作分开，使用者不必关心类对象如何创建。

六、缺点
如果增加新的产品,则修改抽象工厂和所有的具体工厂,违反了开放封闭原则

==================================================== 分割线 ====================================================
创建型模式---原型模式
一、定义：用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象。

二、特点
1.一个已存在的对象（即原型），通过复制原型的方式来创建一个内部属性跟原型都一样的新的对象，这就是原型模式
2.原型模式的核心是clone方法，通过clone方法来实现对象的拷贝

三、角色说明：
  Prototype（抽象原型类）：抽象类或者接口，用来声明clone方法。
  ConcretePrototype1、ConcretePrototype2（具体原型类）：即要被复制的对象。
  Client（客户端类）：即要使用原型模式的地方。

四、应用场景
1.如果初始化一个类时需要耗费较多的资源，比如数据、硬件等等，可以使用原型拷贝来避免这些消耗。
2.通过new创建一个新对象时如果需要非常繁琐的数据准备或者访问权限，那么也可以使用原型模式。
3.一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以拷贝多个对象供调用者使用，即保护性拷贝。

五、优点
1.可以解决复杂对象创建时消耗过多的问题，在某些场景下提升创建对象的效率。
2.保护性拷贝，可以防止外部调用者对对象的修改，保证这个对象是只读的。

六、缺点
1.拷贝对象时不会执行构造函数。
2.有时需要考虑深拷贝和浅拷贝的问题。


案件实例：Android中的Intent就实现了Cloneable接口，但是clone()方法中却是通过new来创建对象的

总结：
实际上，调用clone()构造对象时并不一定比new快，使用clone()还是new来创建对象需要根据构造对象的成本来决定，
如果对象的构造成本比较高或者构造比较麻烦，那么使用clone()的效率比较高，否则使用new

==================================================== 分割线 ====================================================
行为型模式---策略模式
一、定义：定义一系列的算法，把每一个算法封装起来,并且使它们可相互替换。策略模式模式使得算法可独立于使用它的客户而独立变化

二、特点
1.策略模式提供了一组算法给客户端调用，使得客户端能够根据不同的条件来选择不同的策略来解决不同的问题
2.如排序算法，可以使用冒泡排序、快速排序等等

三、角色说明：
  Stragety(抽象策略类)：抽象类或接口，提供具体策略类需要实现的接口。
  ConcreteStragetyA、ConcreteStragetyB（具体策略类）：具体的策略实现，封装了相关的算法实现。
  Context（环境类）：用来操作策略的上下文环境。

四、应用场景
1.同一个问题具有不同算法时，即仅仅是具体的实现细节不同时，如各种排序算法等等。
2.对客户隐藏具体策略(算法)的实现细节，彼此完全独立；提高算法的保密性与安全性。
3.一个类拥有很多行为，而又需要使用if-else或者switch语句来选择具体行为时。使用策略模式把这些行为独立到具体的策略类中，可以避免多重选择的结构。

五、优点
1.策略类可以互相替换
2.由于策略类都实现同一个接口，因此他们能够互相替换。
3.耦合度低，方便扩展
4.增加一个新的策略只需要添加一个具体的策略类即可，基本不需要改变原有的代码，符合开闭原则。
5.避免使用多重条件选择语句（if-else或者switch）。

六、缺点
1.策略的增多会导致子类的也会变多
2.客户端必须知道所有的策略类，并自行决定使用哪一个策略类。

案例分析：之前我们用的ListView时都需要设置一个Adapter，而这个Adapter根据我们实际的需求可以用ArrayAdapter、SimpleAdapter等等，这里就运用到策略模式。


==================================================== 分割线 ====================================================
行为型模式---状态模式
一、定义：当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类

二、特点
1.状态模式中的行为是由状态来决定的，即不同状态下的行为也不同
2.状态模式的结构跟策略模式的几乎一样，但其本质是不一样的。策略模式中的行为是彼此独立，能够相互替换的；
而状态模式的行为是平行的，，不同状态下其行为也是不一样的，具有不可替换性

三、角色说明：
State（抽象状态角色）：抽象类或者接口，定义对象的各种状态和行为。
ConcreteState（具体状态角色）：实现抽象角色类，定义了本状态下的行为，即要做的事情。
Context（环境角色）：定义客户端需要的接口，并且负责具体状态的切换。

四、应用场景
1.对象的行为取决于其状态，随着状态改变时其行为也需改变
2.包含大量的与状态相关的条件判断语句时

五、优点
1.每个状态都是一个子类，易于扩展和维护。
2.避免过多的条件语句，使得结构更清晰，提高代码的可维护性。

六、缺点
可能会导致状态子类会过多

==================================================== 分割线 ====================================================
行为型模式---责任链模式
一、定义：一个请求沿着一条“链”传递，直到该“链”上的某个处理者处理它为止

二、特点
1.多个对象中，每个对象都持有下一个对象的引用，这就构成了链这种结构。
2.一个请求通过链的头部，一直往下传递到链上的每一个结点，直到有某个结点对这个请求做出处理为止，这就是责任链模式。
3.责任链模式一般分为处理者与请求者。具体的处理者分别处理请求者的行为。

三、角色说明
Handler（抽象处理者）：抽象类或者接口,定义处理请求的方法以及持有下一个Handler的引用.
ConcreteHandler1,ConcreteHandler2（具体处理者）：实现抽象处理类,对请求进行处理,如果不处理则转发给下一个处理者.
Client (客户端):即要使用责任链模式的地方。

四、说明
1.上面的请求只是一个简单的地址字符串，如果是一些复杂的请求，可以封装成独立的对象。如：普通快递和生鲜快递，生鲜快递还需快递员做冷链处理等等。
2.请求实际上可以从责任链中的任意结点开始，即可以从上海快递员开始处理也行；
3.责任链中的结点顺序实际也可以调整，即北京->广州->上海的顺序也行；
4.责任链也可以越过某些结点去处理请求，如北京->广州，越过了上海。
5.对于请求，只有两种结果：一是某个结点对其进行了处理，如上面例子的上海、广州快递，这种叫纯的责任链；另一个则是所有结点都不进行处理，如美国的快递，这种叫不纯的责任链。我们所见到的基本都是不纯的责任链。

五、应用场景
1.多个对象处理同一请求时，但是具体由哪个对象去处理需要运行时做判断。
2.具体处理者不明确的情况下，向这组对象提交了一个请求。

六、优点
1.代码的解耦，请求者与处理者的隔离分开。
2.易于扩展，新增处理者往链上加结点即可。

七、缺点
1.责任链过长的话，或者链上的结点判断处理时间太长的话会影响性能，特别是递归循环的时候。
2.请求有可能遍历完链都得不到处理。

案例分析：OKhttp中对请求的处理也是用到了责任链模式

==================================================== 分割线 ====================================================
行为型模式---观察者模式
一、定义：定义对象间的一种一个对多的依赖关系，当一个对象的状态发送改变时，所以依赖于它的对象都得到通知并被自动更新

二、特点
1.观察者模式又被称作发布/订阅模式。
2.观察者模式主要用来解耦，将被观察者和观察者解耦，让他们之间没有依赖或者依赖关系很小。

三、角色说明
Subject（抽象主题）：又叫抽象被观察者，把所有观察者对象的引用保存到一个集合里，每个主题都可以有任何数量的观察者。抽象主题提供一个接口，可以增加和删除观察者对象。
ConcreteSubject（具体主题）：又叫具体被观察者，将有关状态存入具体观察者对象；在具体主题内部状态改变时，给所有登记过的观察者发出通知。
Observer (抽象观察者):为所有的具体观察者定义一个接口，在得到主题通知时更新自己。
ConcrereObserver（具体观察者）：实现抽象观察者定义的更新接口，当得到主题更改通知时更新自身的状态。

四、应用场景
1.当一个对象的改变需要通知其它对象改变时，而且它不知道具体有多少个对象有待改变时。
2.当一个对象必须通知其它对象，而它又不能假定其它对象是谁
3.跨系统的消息交换场景，如消息队列、事件总线的处理机制。

五、优点
1.解除观察者与主题之间的耦合。让耦合的双方都依赖于抽象，而不是依赖具体。从而使得各自的变化都不会影响另一边的变化。
2.易于扩展，对同一主题新增观察者时无需修改原有代码。

六、缺点
1.依赖关系并未完全解除，抽象主题仍然依赖抽象观察者。
2.使用观察者模式时需要考虑一下开发效率和运行效率的问题，程序中包括一个被观察者、多个观察者，开发、调试等内容会比较复杂，而且在Java中消息的通知一般是顺序执行，那么一个观察者卡顿，会影响整体的执行效率，在这种情况下，一般会采用异步实现。
3.可能会引起多余的数据通知。

案例分析：控件中Listener监听方式，比如RxJava、RxAndroid、EventBus、otto等等


==================================================== 分割线 ====================================================
行为型模式---模板方法模式
一、定义：定义一个操作中的算法框架，而将一些步骤延迟到子类中，使得子类可以不改变一个算法的结构即可重定义算法的某些特定步骤

二、特点
1.模板方法模式主要是用来定义一套流程下来的固定步骤，而具体的步骤实现则可以是不固定的。

三、角色说明
AbstractClass（抽象类）：，定义了一整套算法框架。
ConcreteClass（具体实现类）：具体实现类，根据需要去实现抽象类中的方法。

四、应用场景
1.一次性实现算法的执行顺序和固定不变部分，可变部分则交由子类来实现
2.多个子类中拥有相同的行为时，可以将其抽取出来放在父类中，避免重复的代码
3.使用钩子方法来让子类决定父类的某个步骤是否执行，实现子类对父类的反向控制
4.控制子类扩展。模板方法只在特定点调用钩子方法，这样就只允许在这些点进行扩展

五、优点
1.提高代码复用性，去除子类中的重复代码
2.提高扩展性，不同实现细节放到不同子类中，易于增加新行为

六、缺点
1.每个不同的实现都需要定义一个子类，这会导致类的个数的增加，设计更加抽象

案例分析：Android中View的draw方法就是使用了模板方法模式

==================================================== 分割线 ====================================================
行为型模式---迭代器模式
一、定义：提供一种方法访问一个容器对象中各个元素，而又不需暴露该对象的内部细节。

二、特点
1.迭代器（Iterator）模式，又叫做游标（Cursor）模式
2.Java中的Map、List等等容器，都使用到了迭代器模式。

三、角色说明
Iterator（迭代器接口）：负责定义、访问和遍历元素的接口。
ConcreteIterator（具体迭代器类）:实现迭代器接口。
Aggregate（容器接口）：定义容器的基本功能以及提供创建迭代器的接口。
ConcreteAggregate（具体容器类）：实现容器接口中的功能。
Client（客户端类）：即要使用迭代器模式的地方。

四、应用场景
1.遍历一个容器对象时
2.实际我们开发中很少使用到迭代器模式。虽然不怎么用得到，但是了解其原理能够让我们在看到相关的源码（如Java中的Map、List等等容器）时能够更容易了解源码的相关思想。

五、优点
可以支持以不同的方式去遍历容器对象，如顺序遍历，逆序遍历等等。
符合单一职责原则，容器类与遍历算法的分离，不同类负责不同的功能。
六、缺点
会产生多余的对象，消耗内存。
会增多类文件。
遍历过程是一个单向且不可逆的遍历。
遍历过程需要注意容器是否改变，若期间改变了，可能会抛出异常。

案例分析：Android中使用数据库查询时返回的Cursor游标对象，实际上就是使用了迭代器模式来实现



==================================================== 分割线 ====================================================
行为型模式---备忘录模式
一、定义：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样以后就可以将该对象恢复到先前保存的状态。

二、特点
备忘录模式比较适合用于功能复杂，需要维护和纪录历史的地方，或者是需要保存一个或者多个属性的地方；在未来某个时刻需要时，将其还原到原来纪录的状态

三、角色说明
Originator（发起人角色）：负责创建一个备忘录（Memoto），能够记录内部状态，以及恢复原来记录的状态。并且能够决定哪些状态是需要备忘的。
Memoto（备忘录角色）：将发起人（Originator）对象的内部状态存储起来；并且可以防止发起人（Originator）之外的对象访问备忘录（Memoto）。
Caretaker（负责人角色）：负责保存备忘录（Memoto），不能对备忘录（Memoto）的内容进行操作和访问，只能将备忘录传递给其他对象。

四、应用场景
需要保存对象的某一时刻的状态时

五、优点
1.能够让状态回滚到某一时刻的状态
2.实现了状态保存对象的封装，用户无需关心其实现细节。

六、缺点
要保存的对象如果成员变量过多的话，资源消耗也会相应增多

案例分析：Activity中的onSaveInstanceState和onRestoreInstanceState


==================================================== 分割线 ====================================================
行为型模式---访问者模式
一、定义：封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作。

二、特点
1.访问者模式是一种将数据结构和数据操作分离的设计模式。
2.访问者模式比较复杂，而且实际使用的地方并不多。
3.访问者模式适用于数据结构稳定的元素操作上，一旦数据结构易变，则不适用

三、角色说明
Visitor（抽象访问者）：接口或者抽象类，为每一个元素（Element）声明一个访问的方法。
ConcreteVisitor（具体访问者）：实现抽象访问者中的方法，即对每一个元素都有其具体的访问行为。
Element（抽象元素）：接口或者抽象类，定义一个accept方法，能够接受访问者（Visitor）的访问。
ConcreteElementA、ConcreteElementB（具体元素）：实现抽象元素中的accept方法，通常是调用访问者提供的访问该元素的方法。
Client（客户端类）：即要使用访问者模式的地方。


四、应用场景
1.对象结构比较稳定，很少改变，但是经常需要在此对象结构上定义新的操作行为时
2.需要对一个对象结构中的对象进行很多不同的并且不相关的操作,它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作

五、优点
1.各种角色各司其职，符合单一职责原则
2.原有的类上新增操作只需实现一个具体访问者就可以，不 必修改整个类层次，符合开闭原则
3.良好的扩展性，新增访问操作变得简单
4.数据操作和数据结构的解耦

六、缺点
1.具体元素对访问者公布了实现细节，破坏了类的封装性，违反了迪米特原则
2.违反了依赖倒置原则，为了达到区别对待依赖了具体而不是抽象
3.具体元素修改的成本太大
4.新增具体元素困难，需要在抽象访问者角色中增加一个新的抽象操作，违反了开闭原则


访问者模式实际使用中比较少，但是真正需要用到时，还是很有用的

==================================================== 分割线 ====================================================







==================================================== 分割线 ====================================================