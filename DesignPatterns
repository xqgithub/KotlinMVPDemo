Android的设计模式-设计模式的六大原则:
一、单一职责原则：一个类应只包含单一的职责
1.一个类职责过大的话，首先引起的问题就是这个类比较大，显得过于臃肿，同时其复用性是比较差的
2.其次就是如果修改某个职责，有可能引起另一个职责发生错误。这是我们极力所避免的，因此设计一个类时我们应当去遵循单一职责原则
二、开放封闭原则：一个模块、类、函数应当是对修改关闭，扩展开放
1.修改原有的代码可能会导致原本正常的功能出现问题
2.因此，当需求有变化时，最好是通过扩展来实现，增加新的方法满足需求，而不是去修改原有代码
三、里氏代换原则：使用父类的地方能够使用子类来替换，反过来，则不行
1.使用子类对象去替换父类对象，程序将不会产生错误
2.因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象
四、依赖倒转原则：抽象不应该依赖于细节，细节应当依赖于抽象
1.即要面向接口编程，而不是面向具体实现去编程
2.高层模块不应该依赖低层模块，应该去依赖抽象
五、接口隔离法则：一个类对另一个类的依赖应该建立在最小的接口上
1.一个类不应该依赖他不需要的接口
2.接口的粒度要尽可能小，如果一个接口的方法过多，可以拆成多个接口
六、迪米特法则：一个类尽量不要与其他类发生关系
1.一个类对其他类知道的越少，耦合越小
2.当修改一个类时，其他类的影响就越小，发生错误的可能性就越小

==================================================== 分割线 ====================================================
创建型模式---单例模式
一、定义：确保某个类只有一个实例,并且自行实例化并向整个系统提供这个实例

二、特点
 1. 单例类只能有一个实例。
 2. 单例类必须自己创建自己的唯一实例。
 3. 单例类必须给所有其他对象提供这一实例。

三、类型
1.饿汉式
优点：写法简单，线程安全。
缺点：没有懒加载的效果，如果没有使用过的话会造成内存浪费。
2.懒汉式（线程不安全）
优点：实现了懒加载的效果。
缺点：线程不安全。
3.懒汉式（线程安全）
优点：实现了懒加载的效果，线程安全。
缺点：使用synchronized会造成不必要的同步开销，而且大部分时候我们是用不到同步的。
4.双重检查锁定(DCL)
优点：懒加载，线程安全，效率较高
缺点：volatile影响一点性能，高并发下有一定的缺陷，某些情况下DCL会失效，虽然概率较小。
5.静态内部类
优点：懒加载，线程安全，推荐使用
6.枚举单例
优点：线程安全，写法简单，能防止反序列化重新创建新的对象。
缺点：可读性不高，枚举会比静态常量多那么一丁点的内存。

四、应用场景
频繁访问数据库或文件的对象。
工具类对象；
创建对象时耗时过多或耗费资源过多，但又经常用到的对象；

五、优点
内存中只存在一个对象，节省了系统资源。
避免对资源的多重占用，例如一个文件操作，由于只有一个实例存在内存中，避免对同一资源文件的同时操作。

六、缺点
获取对象时不能用new
单例对象如果持有Context，那么很容易引发内存泄露。
单例模式一般没有接口，扩展很困难，若要扩展，只能修改代码来实现。
==================================================== 分割线 ====================================================
创建型模式---建造者模式
一、定义：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

二、特点：
1.建造者模式主要用来创建复杂的对象，用户可以不用关心其建造过程和细节。
2.例如：当要组装一台电脑时，我们选择好CPU、内存、硬盘等等，然后交给装机师傅，装机师傅就把电脑给组装起来，我们不需要关心是怎么拼装起来的。

三、角色说明：
Product（产品类）：要创建的复杂对象。在本类图中，产品类是一个具体的类，而非抽象类。实际编程中，产品类可以是由一个抽象类与它的不同实现组成，也可以是由多个抽象类与他们的实现组成。
Builder（抽象建造者）：创建产品的抽象接口，一般至少有一个创建产品的抽象方法和一个返回产品的抽象方法。引入抽象类，是为了更容易扩展。
ConcreteBuilder（实际的建造者）：继承Builder类，实现抽象类的所有抽象方法。实现具体的建造过程和细节。
Director（指挥者类）：分配不同的建造者来创建产品，统一组装流程。

四、应用场景
创建一些复杂的对象时,对象内部的构建过程存在复杂变化。
相同的构建过程，不同的执行顺序，产生不同结果时。
不同配置的构建对象，产生不同结果时。

五、优点
封装性良好，隐藏内部构建细节。
易于解耦，将产品本身与产品创建过程进行解耦，可以使用相同的创建过程来得到不同的产品。也就说细节依赖抽象。
易于扩展，具体的建造者类之间相互独立，增加新的具体建造者无需修改原有类库的代码。
易于精确控制对象的创建，由于具体的建造者是独立的，因此可以对建造过程逐步细化，而不对其他的模块产生任何影响。

六、缺点
产生多余的Builder对象以及Director类。
建造者模式所创建的产品一般具有较多的共同点，其组成部分相似；如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。


举例分析：Android中的AlertDialog.Builder就是使用了Builder模式来构建AlertDialog的
==================================================== 分割线 ====================================================